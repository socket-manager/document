<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>アーキテクチャ | SOCKET-MANAGER Framework For PHP</title>
        <meta name="description" content="フレームワークのアーキテクチャを図解とともにご紹介します" />
        <meta content="PHP,ソケット通信,フレームワーク,サーバー" name="keywords">

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LF9W695NNW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-LF9W695NNW');
        </script>
        <link rel="icon" href="./favicon.ico" type="image/x-icon" />
        <link type="text/css" rel="stylesheet" href="./css/common.css" media="all" />
        <script src="./js/jquery-3.7.1.min.js"></script>
        <script type="text/javascript" src="./js/common.js"></script>
    </head>
    <body>
        <div class="layout">
            <div class="menu">
                <h2 class="menu-title">SOCKET-MANAGER</h2>
                <h4 class="menu-reference menu-page-title-link"><a href="./reference/index.html" target="blank">&gt;&gt; Reference</a></h4>
                <h2 class="menu-label">MAIN-MENU</h2>
                <div class="menu-text">

                    <h3 class="menu-page-title-link"><a href="./index.html">▶フレームワークのご紹介</a></h3>

                    <h3 class="menu-page-title-link"><a href="./websocket.html">▶Websocket開発環境</a></h3>

                    <h3 class="menu-page-title-link"><a href="./new-project.html">▶新規プロジェクト開発環境</a></h3>

                    <h3 class="menu-page-title-link"><a href="./laravel.html">▶Laravelと連携する</a></h3>

                    <h3 class="menu-page-title">▼アーキテクチャ</h3>

                    <ul>
                        <li><a href="./architecture.html#begin">はじめに</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#outline">レイヤー概念図</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#que_and_unit">キューとUNITの関係</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#unit-implementation">UNIT定義クラス</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#init">初期化クラス</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#main">メイン処理クラス</a></li>
                    </ul>
                    <ul>
                        <li><a href="./architecture.html#last">おわりに</a></li>
                    </ul>

                    <h3 class="menu-page-title-link"><a href="./multi-server.html">▶マルチサーバーの構成</a></h3>

                    <h3 class="menu-page-title-link"><a href="./system-setting.html">▶システム設定ファイル</a></h3>

                </div>
                <h2 class="menu-label">EXTRA-MENU</h2>
                <div class="menu-text">

                    <h3 class="menu-page-title-link"><a href="./extra-demo.html">▶デモサーバーの種類</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-demo-command.html">▶デモのコマンド仕様</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-demo-setting.html">▶デモの設定ファイル</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-minecraft.html">▶マインクラフトの通信仕様</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-close-frame.html">▶切断フレームの検証</a></h3>

                </div>
                <div class="menu-line"></div>
                <div class="menu-text">

                    <h3 class="menu-page-title-link"><a href="./minecraft-contents/index.html">&gt;&gt; マインクラフトの環境</a></h3>

                </div>
            </div>
            <div class="main">

                <h1>【アーキテクチャ】</h1>

                <a id="begin"></a>
                <h2 class="subtitle">はじめに</h2>

                <div class="text-block">
                    ここではシステム特有の用語を含めたメカニズムや考え方を説明しています。<br />
                    ノンブロッキングによる実装を前提としており、全接続を並行処理可能にしているためプロセスのフォークは行っていません。
                </div><br />

                <a id="outline"></a>
                <h2 class="subtitle">レイヤー概念図</h2>

                <div class="text-block">
                    <div class="img-block">
                        <a href="./img/architecture/outline.png" target="blank"><img class="img-zoomout" src="./img/architecture/outline.png" /></a>
                    </div>
    
                    サーバーのアプリケーションの部分はプロトコル部とコマンド部に大きく分かれています。<br />
                    最初にそれらをライブラリ内の<code>CycleDrivenManager</code>のプロトコル部とコマンド部へ取り込ませてから使う事になります。<br /><br />

                    プロトコル部とコマンド部に分けているのは、それぞれを自由に入れ替える事ができるようにするためです。<br />
                    作成したクライアントのプロトコルに合わせてプロトコル部を入れ替えたり、サーバーサイドのコンテンツを切り替えるためにコマンド部を入れ替えたりする事で様々な種類のサーバーを構築する事ができます。
                </div><br />

                <a id="que_and_unit"></a>
                <h2 class="subtitle">キューとUNITの関係</h2>

                <div class="text-block">
                    まずは<code>CycleDrivenManager</code>の動きを理解するためにキューとステータスUNITの関係を知る必要があります。<br />
                    図にすると以下のようなイメージになります。

                    <div class="img-block">
                        <a href="./img/architecture/que-and-unit.png" target="blank"><img class="img-zoomout" src="./img/architecture/que-and-unit.png" /></a>
                    </div>
    
                    通信データの送受信の特徴として送りたいデータ、あるいは欲しいデータが一度で全て送信／受信できるとは限らないためこのような構成になっています。<br /><br />

                    例えばWebsocketのopeningハンドシェイクの場合はクライアントからヘッダ情報を受信した後は同じようにヘッダ情報をサーバーから送り返さないといけませんが、これをブロッキングモードで送信が完了するまで待っていると他の接続も巻き込んで処理が待たされる事になってしまいます。<br /><br />

                    この回避策として当ライブラリでは以下のUNIT処理のようにノンブロッキングモードで送信が行えるようにしています。<br />

                    <span>UNIT処理の一部を抜粋</span>
                    <pre color-change="php">
// CREATEステータスのUNIT
{
    // 送信データの設定
    $p_param->protocol()->setSendingData(<送信データ>);

    return ProtocolStatusEnumForWebsocket::SEND->value;
}

// SENDステータスのUNIT
{
    // データ送信
    $w_ret = $p_param->protocol()->sending();

    // 送信中の場合は再実行
    if($w_ret === null)
    {
        $sta = $p_param->getStatusName();
        return $sta;
    }

    return null;
}
                    </pre><br />

                    実際にデータを送信する<code>SEND</code>ステータスのひとつ前のUNIT処理（<code>CREATE</code>ステータス）であらかじめ送信したいデータを設定しておき、送信を実行するUNIT処理（<code>SEND</code>ステータス）で<code>sending</code>メソッドの戻り値がnull以外になるまで繰り返しています。<br /><br />

                    ※<code>sending</code>メソッドは設定された送信データを送信しきるまでnullを返す処理です。<br />
                    ※<code>getStatusName</code>メソッドは現在実行中のステータス名を取得するものです。<br /><br />

                    受信の場合も同じように受信サイズを設定するメソッド<code>setReceivingSize</code>と受信しきるまでnullを返すメソッド<code>receiving</code>に分けています。<br /><br />

                    このようにUNITの処理の実装は極力処理の停滞（ブロッキング）がおきないように構成する事が求められます。<br /><br />

                    また、UNITステータスはリターン値によって遷移していきます。そしてキューの処理が全て完了したらnullを返すルールとなっています。<br />
                    処理の流れはリターン値で制御できるので、同じような処理を繰り返し行ったり、分岐したいケースがある場合には処理を構造化しながらコントロールする事が可能になります。<br /><br />

                    このようなキューとステータスUNITをコントロールする役割を<code>CycleDrivenManager</code>が担っています。<br /><br />

                    <h3 class="underline">throwブレイク</h3>

                    このシステムでのthrowブレイクは、UNITのステータスを維持したまま処理を中断して待ち受け状態に戻る事を意味します。<br />
                    ステータスUNIT内で<code>UnitException</code>クラスを用いて例外（throw）を発行する事でthrowブレイクとなります。
                </div><br />

                <a id="unit-implementation"></a>
                <h2 class="subtitle">UNIT定義クラス</h2>

                <div class="text-block">
                    UNITの処理はプロトコル／コマンド部を問わず<code>IEntryUnits</code>インタフェースに従って実装する必要があります。<br />
                    プロトコル部を作成する時は<code>craft:protocol</code>コマンドを、コマンド部を作成する時は<code>craft:command</code>コマンドを実行してファイルを生成します。<br />
                    生成されるファイルの種類は以下の通り。<br />

                    <ul>
                        <li>UNIT定義クラス</li>
                        <li>キュー名定義のEnum</li>
                        <li>ステータス名定義のEnum</li>
                    </ul>

                    UNIT定義クラスの実装イメージは次の通りです。<br />
                    <div class="img-block">
                        <a href="./img/architecture/unit_class.png" target="blank"><img class="img-zoomout" src="./img/architecture/unit_class.png" /></a>
                    </div>

                    プロトコル部のキュー名は<code>ProtocolQueueEnum</code>で予約されているので、作成されたEnumファイルにはこの予約されたEnum値がエイリアス名として定義されます。<br /><br />

                    コマンド部のキュー名の定義は自由です。UNIT定義クラスの実装に合わせてキュー名を追加していく事になります。<br /><br />

                    <dl>
                        <dt>■getQueueListメソッドの実装</dt>
                        <dd>プロトコル部、コマンド部それぞれで定義されたキュー名のEnum値をピックアップしてリストに追加します。</dd>
                        <dt>■getUnitListメソッドの実装</dt>
                        <dd>引数で渡されたキュー名と一致するリストを返します。プロトコル部、コマンド部それぞれで定義されたステータス名定義のEnum値をピックアップしてステータス名に対応するUNITメソッドとセットでリストを作成します。各キューの処理は<code>START</code>ステータスから始まるので必ず含める必要があります。</dd>
                    </dl>
                </div><br/>

                <a id="init"></a>
                <h2 class="subtitle">初期化クラス</h2>

                <div class="text-block">
                    初期化クラスは<code>IInitSocketManager</code>インタフェースに従って実装する必要があります。<br />
                    インタフェース実装に必要な内容は以下の通りです。<br /><br />

                    <h3 class="underline">UNITパラメータクラス</h3>

                    <code>SocketManagerParameter</code>クラスやそれを継承しているクラスの事をUNITパラメータクラスと呼びます。<br />
                    このインスタンスはUNIT処理の引数として渡されるもので、<code>SocketManager</code>との橋渡し役を担っています。<br /><br />

                    <code>SocketManagerParameter</code>クラスを継承する事でデータの送受信やディスクリプタ（クライアント接続子）の操作を行うための機能を提供すると同時に、アプリケーションで利用するグローバルエリアを管理する役割も担っています。<br />
                    プロトコル部・コマンド部・コマンドディスパッチャー間で同じグローバルエリアの利用が可能です。<br />
                    接続子単位でのグローバル管理が必要なデータに関しては、UNITパラメータクラス内の<code>getTempBuff/setTempBuff</code>メソッドで取得・設定が可能です。<br />
                    これを図にすると以下のようになります。<br />

                    <div class="img-block">
                        <a href="./img/architecture/global.png" target="blank"><img class="img-zoomout" src="./img/architecture/global.png" /></a>
                    </div>

                    初期化クラス内の<code>getUnitParameterメソッド</code>でインスタンスを返す必要がありますが、インスタンス化するタイミングは初期化クラスの内側／外側を問いません。<br /><br />

                    プロトコル部ではUNITパラメータクラス内でインプリメントされた<code>IProtocolParameter</code>インタフェースを返す<code>protocol</code>メソッドを介して送受信用のメソッドを使う必要があります。<br />
                    protocolメソッドをコマンド部で呼び出すとエラーになりますのでご注意ください。<br /><br />

                    詳しくは<code>SocketManagerParameter</code>クラスの<font class="code"><a href="./reference/classes/SocketManager-Library-SocketManagerParameter.html" target="_blank">&gt;&gt; Reference</a></font>をご覧ください。<br /><br />

                    <h3 class="underline">シリアライザー／アンシリアライザー</h3>

                    この処理はディスクリプタ内で管理された先入れ先出し方式である送受信スタックエリア（メモリ上のスタック領域とは無関係です）と深く関わっています。<br />
                    送受信スタックエリア内ではシリアライズ化されたデータが保持されるため、データ取得時にはアンシリアライザーが、データ設定時にはシリアライザーが呼び出されます。<br />
                    これを図にすると以下のようになります。<br /><br />

                    <div class="img-block">
                        <a href="./img/architecture/data_stack.png" target="blank"><img class="img-zoomout" src="./img/architecture/data_stack.png" /></a>
                    </div>

                    <h3 class="underline">コマンドディスパッチャー</h3>

                    プロトコル部で受信したデータはUNITパラメータクラスの<code>setRecvStack</code>メソッドを使って受信スタックへ格納する必要があります。<br />
                    コマンドディスパッチャーはその受信データを解析してコマンド部に処理を振り分ける役割を担っています。<br /><br />

                    コマンド部から送信するデータはUNITパラメータクラスの<code>setSendStack</code>メソッドを使って送信スタックへ格納する必要があります。<br />
                    送信時はコマンドディスパッチャーの介入はなく、送信スタックに溜まったものをプロトコル部を経由して順次クライアントへ送信されます。<br /><br />

                    これを図にすると以下のようになります。<br /><br />

                    <div class="img-block">
                        <a href="./img/architecture/recv_flow.png" target="blank"><img class="img-zoomout" src="./img/architecture/recv_flow.png" /></a>
                    </div>

                    <div class="img-block">
                        <a href="./img/architecture/send_flow.png" target="blank"><img class="img-zoomout" src="./img/architecture/send_flow.png" /></a>
                    </div>

                    <h3 class="underline">緊急停止時のコールバック</h3>

                    以下の場面で呼び出されます。<br />
                    <ul>
                        <li>アライブチェック処理のタイムアウト</li>
                        <li>コマンドディスパッチャーで例外キャッチ時</li>
                        <li>相手先による強制切断</li>
                    </ul><br />

                    <h3 class="underline">ログライター</h3>

                    ライブラリ内を含めアプリケーションレイヤー内からも呼ばれるログ出力ハンドラーです。<br />
                    アプリケーションレイヤーからはUNITパラメータクラスを通して呼ばれます。<br />
                </div><br />

                <a id="main"></a>
                <h2 class="subtitle">メイン処理クラス</h2>

                <div class="text-block">
                    実装イメージは以下の通りです。<br />

                    <div class="img-block">
                        <a href="./img/architecture/main_class.png" target="blank"><img class="img-zoomout" src="./img/architecture/main_class.png" /></a>
                    </div>

                    このうち初期設定ブロックは<code>SocketManager</code>の準備処理として必要な部分です。<br />
                    ポート設定ブロックではマルチサーバーの子サーバーとして起動する場合、親サーバーへの接続を行うための<code>connect</code>メソッドが使用される事があります。<br />
                    ノンブロッキングループブロックは以下のイメージで動作します。<br />

                    <div class="img-block">
                        <a href="./img/architecture/main1.png" target="blank"><img class="img-zoomout" src="./img/architecture/main1.png" /></a>
                    </div>

                    １つの接続に対してプロトコル部とコマンド部が連携し合って動作します。<br />
                    このうち１回の周期（ループ）で実行されるのはプロトコル／コマンド部のそれぞれ１UNITずつとなります。<br />
                    これが複数の接続になると以下のイメージになり、１つのサーバーで処理する単位になります。<br />

                    <div class="img-block">
                        <a href="./img/architecture/main2.png" target="blank"><img class="img-zoomout" src="./img/architecture/main2.png" /></a>
                    </div>

                    そして複数のサーバーを起動している場合は以下のイメージになり、プロセスが順当に割り当てられると１つのサーバープロセスがCPUの各コア（このケースではコアが４つの場合）に割り当てられてデュアルで動作します。<br />

                    <div class="img-block">
                        <a href="./img/architecture/main3.png" target="blank"><img class="img-zoomout" src="./img/architecture/main3.png" /></a>
                    </div>

                    ※実際にサーバーをスケーリングする際には上記のイメージを基に計算／設計していく事になりますが、サーバー上には多数のプロセスが存在するため必ずしも<code>SocketManager</code>のプロセスが４つとも常に割り当てられるとは限らないので、リソースや処理時間等の実測値を見ながら調整していく事になります。<br /><br />
                </div>

                <a id="last"></a>
                <h2 class="subtitle">おわりに</h2>

                <div class="text-block">
                    ここでご紹介した内容は特に新規プロジェクト開発をする時に必要になる情報ばかりですが、Websocket開発環境でもより高度な実装をするために必要な情報でもあります。<br />
                    サーバー間通信を伴うマルチサーバーを構築する際の基礎的な内容でもありますので<font><a href="./multi-server.html" target="_blank">▶マルチサーバーの構成</a></font>のページも合わせてご覧ください。
                </div>
            </div>
        </div>
    </body>
</html>
