<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>マイクラコンテンツ用 | SOCKET-MANAGER Framework For PHP</title>
        <meta name="description" content="マインクラフト専用コンテンツを扱うプロジェクト環境についてご紹介します" />
        <meta content="bedrock,websocket,マインクラフト,統合版,minecraft" name="keywords">

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LF9W695NNW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-LF9W695NNW');
        </script>
        <link rel="icon" href="./favicon.ico" type="image/x-icon" />
        <link type="text/css" rel="stylesheet" href="././css/common.css" media="all" />
        <script src="././js/jquery-3.7.1.min.js"></script>
        <script type="text/javascript" src="././js/common.js"></script>
    </head>
    <body>
        <div class="layout">
            <div class="menu">
                <h2 class="menu-title">SOCKET-MANAGER</h2>
                <h4 class="menu-reference menu-page-title-link"><a href="./reference/index.html" target="blank">&gt;&gt; Reference</a></h4>
                <h2 class="menu-label">MAIN-MENU</h2>
                <div class="menu-text">

                    <h3 class="menu-page-title-link"><a href="./index.html">▶フレームワークのご紹介</a></h3>

                    <h3 class="menu-page-title-link"><a href="./websocket.html">▶Websocket開発環境</a></h3>

                    <h3 class="menu-page-title-link"><a href="./new-project.html">▶新規プロジェクト開発環境</a></h3>

                    <h3 class="menu-page-title-link"><a href="./laravel.html">▶Laravelと連携する</a></h3>

                    <h3 class="menu-page-title-link"><a href="./architecture.html">▶アーキテクチャ</a></h3>

                    <h3 class="menu-page-title-link"><a href="./multi-server.html">▶マルチサーバーの構成</a></h3>

                    <h3 class="menu-page-title-link"><a href="./system-setting.html">▶システム設定ファイル</a></h3>

                </div>
                <h2 class="menu-label">EXTRA-MENU</h2>
                <div class="menu-text">

                    <h3 class="menu-page-title-link"><a href="./extra-demo.html">▶デモサーバーの種類</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-demo-command.html">▶デモのコマンド仕様</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-demo-setting.html">▶デモの設定ファイル</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-minecraft.html">▶マインクラフトの通信仕様</a></h3>

                    <h3 class="menu-page-title-link"><a href="./extra-close-frame.html">▶切断フレームの検証</a></h3>

                    <h3 class="menu-page-title">▼マイクラコンテンツ用</h3>

                    <ul>
                        <li><a href="./extra-minecraft-contents.html#begin">はじめに</a></li>
                    </ul>
                    <ul>
                        <li><a href="./extra-minecraft-contents.html#project">プロジェクト環境</a></li>
                    </ul>
                    <ul>
                        <li><a href="./extra-minecraft-contents.html#behavior">ビヘイビアパックの適用</a></li>
                    </ul>
                    <ul>
                        <li><a href="./extra-minecraft-contents.html#contents">コンテンツ</a></li>
                    </ul>
                    <ul>
                        <li><a href="./extra-minecraft-contents.html#last">おわりに</a></li>
                    </ul>

                </div>
            </div>
            <div class="main">

                <h1>【マイクラコンテンツ用】</h1>

                <a id="begin"></a>
                <h2 class="subtitle">はじめに</h2>

                <div class="text-block">
                    ここではWebsocketサーバーを使った運用を前提としています。<br />
                    スコアボードやコマンドを駆使して四苦八苦しながらイベントを判定したりするのを避け、サーバープログラミングを使って極力運用の負担を減らそうというのが狙いです。<br />
                    基本的にはファミリー向けに楽しく遊べるものを目指しているので、グローバルコンテンツや商用利用は今のところ考えていません。<br /><br />

                    サーバーフレームワークのご紹介時に利用したデモ環境は、マインクラフト（統合版）を含めたWebsocket用チャットサーバーの実装例としてご紹介していましたが、ここではマインクラフト専用のコンテンツとしてプロジェクト環境を構築しているので別物だとお考えください。<br /><br />

                    ※この環境はデモ環境をベースに構築しているのでチャット機能も引き継いでいます。<br />
                </div><br />

                <a id="project"></a>
                <h2 class="subtitle">プロジェクト環境</h2>

                <div class="text-block">
                    マインクラフト用のプロジェクト環境は以下のコマンドでインストールできます。<br />
                    ※GitHubから直接ダウンロードする場合は<font><a href="https://github.com/socket-manager/contents-project" target="_blank">&gt;&gt; こちら</a></font>からどうぞ。<br />

                    <span>インストールコマンド</span>
                    <pre color-change="command">
> composer create-project socket-manager/contents-project <インストール先のディレクトリ名>
                    </pre><br />

                    インストール後のディレクトリ構成は以下のようになっています。<br />
                    <span>ディレクトリ構成</span>
                    <pre>
/app
    /client             Webブラウザ用クライアント
        /jquery         jQuery版
        /react          React版
    /behavior_packs     ビヘイビアパック（マインクラフト用）
    /InitClass          初期化クラス
    /UnitParameter      UNITパラメータクラス
    /ProtocolUnits      プロトコルUNIT定義クラス
    /CommandUnits       コマンドUNIT定義クラス
    /MainClass          メイン処理クラス
/logs                   ログ出力用
/setting                設定ファイル用
                    </pre><br />

                    Webブラウザ用クライアントディレクトリにはデモ環境と同じくjQuery版とReact版のHTMLファイル（chat.html）が入っていますのでお好きな方をブラウザにドラッグ＆ドロップしてお使いください。<br /><br />

                    専用アイテムを有効にするためにはマインクラフトワールドデータのルートテーブルを触る必要があります。<br />
                    今回使用しているルートテーブルの追加分をプロジェクト内の<code>app/behavior_packs</code>ディレクトリにビヘイビアパックとして同梱しています。<br />
                    このディレクトリの中身をそのまま統合版ゲームデータの<code>behavior_packs</code>ディレクトリにコピーしてお使いください（詳細は<font><a href="./extra-minecraft-contents.html#behavior">&lt;&lt; こちら</a></font>）。<br /><br />

                    サーバーの起動方法はデモ環境と全く同じです。<br />
                    例えばマインクラフト用のWebsocketサーバーを起ち上げる場合にはプロジェクトルートで以下のようにコマンドを実行すれば起動します。<br />

                    <span>サーバーの起動（10000ポートで起動する場合）</span>
                    <pre color-change="command">
&gt; php worker app:minecraft-chat-server 10000
                    </pre><br />

                    マインクラフトはUWPアプリのためlocalhost（127.0.0.1）で利用する場合は以下のコマンドを実行してループバックアドレスへのアクセスを許可しておく必要があります。<br />

                    <span>ループバックアドレス許可の設定</span>
                    <pre color-change="command">
> CheckNetIsolation.exe LoopbackExempt -a -n="Microsoft.MinecraftUWP_8wekyb3d8bbwe"
                    </pre><br />

                    マインクラフトからWebsocketサーバーへ接続する時はチャット画面で以下のように入力します。
                    <img src="./img/extra-minecraft-contents/command_wsserver.png" /><br /><br />

                    <span>入力書式（10000ポートに接続する場合）</span>
                    <pre color-change="command">
> /wsserver localhost:10000/<ユーザー名>
                    </pre><br />
                    
                    上記のユーザー名はマインクラフト内のユーザー名でなくても構いません。<br />
                    あくまでWebsocketサーバー内で使用する名前です。<br /><br />

                    <img src="./img/extra-minecraft-contents/complete_wsserver.png" /><br /><br />

                    接続が完了すれば画面左上に上記のようなメッセージが表示されます。<br />
                    接続後は<font><a href="./extra-minecraft-contents.html#contents">&gt;&gt; コンテンツ</a></font>の項目でご紹介している機能が使えるようになります。
                </div><br />

                <a id="behavior"></a>
                <h2 class="subtitle">ビヘイビアパックの適用</h2>

                <div class="text-block">
                    ここでは<code>contents-project</code>環境に同梱しているビヘイビアパックの適用方法について説明します。<br />
                    Websocketサーバーはホストプレイでのみ利用可能なのでPC内の以下のフォルダへコピーして使います。<br />

                    <span>ゲームデータのホームフォルダ</span>
                    <pre>
C:\Users\&lt;PCのユーザー名&gt;\AppData\Local\Packages\Microsoft.MinecraftUWP_8wekyb3d8bbwe\LocalState\games\com.mojang
                    </pre><br />

                    <h3 class="underline">カスタムビヘイビアパックをコピー</h3>
                    プロジェクト環境の<code>app/behavior_packs</code>フォルダ内には以下の構成でファイルが格納されています。<br />
                    <code>manifest.json</code>には、ビヘイビアパック名「family-customize」で登録してあります。<br />

                    <span>カスタムビヘイビアパックの内容</span>
                    <pre>
/for-family
    manifest.json                   マインクラフトがビヘイビアパックを認識するための情報
    pack_icon.png                   ビヘイビアパックのアイコン
    /functions
        arrow_thunder.mcfunction    「いなずまの矢」へ稲妻を落とすコマンド
        arrow_explode.mcfunction    「はかいの矢」へ稲妻を落とすコマンド
        tag_cheat.mcfunction        「いなずまの矢」へタグを付与するコマンド
        double_jump.mcfunction      二段ジャンプを実行するコマンド
    /loot_tables
        arrow_thunder.json          「いなずまの矢」を取得するルートテーブル
        arrow_explode.json          「はかいの矢」を取得するルートテーブル
        bow_thunder.json            「いなずまの弓」を取得するルートテーブル
                    </pre><br />

                    ※「いなずまの弓」についての詳細は<font><a href="./extra-minecraft-contents.html#bow_thunder">&gt;&gt; こちら</a></font><br />
                    ※「いなずまの矢」についての詳細は<font><a href="./extra-minecraft-contents.html#arrow_thunder">&gt;&gt; こちら</a></font><br /><br />

                    上記の<code>for-family</code>フォルダを以下のゲームデータのフォルダへコピーします。<br />
                    <img src="./img/extra-minecraft-contents/behavior_pack_folder.png" /><br /><br />

                    <br />
                    <h3 class="underline">ワールドを新規で作成する場合</h3>

                    <br />
                    以下のワールド作成画面から左メニューの「ビヘイビアーパック」を選択すると右側に<code>family-customize</code>（今回コピーしたカスタムビヘイビアパック）というビヘイビアパックが表示されます。<br />
                    そして<code>family-customize</code>項目右側の「有効化」ボタンをクリックします。<br />
                    <img src="./img/extra-minecraft-contents/new_world_setting_behavior2.png" /><br /><br />

                    すると以下の画面のようにダイアログが表示されるので「続ける」をクリックします。<br />
                    ※今回のビヘイビアパックでは対応するリソースパックを作っていないので以下のような確認ダイアログが表示されますがそのまま継続しても大丈夫です。<br />
                    <img src="./img/extra-minecraft-contents/new_world_setting_behavior3.png" /><br /><br />

                    以下のような表示が出たら設定完了です。<br />
                    あとは「作成」ボタンを押して新しいワールドへログインしてください。<br />
                    <img src="./img/extra-minecraft-contents/new_world_setting_behavior4.png" /><br /><br />

                    <br />
                    <h3 class="underline">存在するワールドに適用する場合</h3>

                    <br />
                    以下のワールド選択画面から今回のカスタムビヘイビアパックを適用するワールドの鉛筆マークのボタンをクリックします。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_button.png" /><br /><br />

                    ワールド設定画面の左側のメニューから「ビヘイビアーパック」をクリックします。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior.png" /><br /><br />

                    右側の「マイパック」プルダウン項目を開いて<code>family-customize</code>のビヘイビアパックを選択すると、その下に「有効化」ボタンが表示されますのでそれをクリックします。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior3.png" /><br /><br />

                    すると以下の画面のようにダイアログが表示されるので「続ける」をクリックします。<br />
                    ※今回のビヘイビアパックでは対応するリソースパックを作っていないので以下のような確認ダイアログが表示されますがそのまま継続しても大丈夫です。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior4.png" /><br /><br />

                    以下のように画面上部に「family-customizeがアクティブ化されました」と表示が出たら設定完了です。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior5.png" /><br /><br />

                    右側の「使用中」のプルダウン項目を開くと<code>family-customize</code>のビヘイビアパックが最上部に適用されている事が確認できます。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior6.png" /><br /><br />

                    <code>family-customize</code>のビヘイビアパックを再び選択すると「無効化」ボタンが表示されますので、これをクリックすると有効化した後でも無効にする事ができます。<br />
                    <img src="./img/extra-minecraft-contents/edit_world_setting_behavior7.png" /><br /><br />
                </div><br />

                <a id="contents"></a>
                <h2 class="subtitle">コンテンツ</h2>

                <div class="text-block">
                    本プロジェクト環境で実装しているコンテンツのご紹介です。<br /><br /><br />

                    <h3 class="underline">チャット機能</h3>

                    <br />
                    <dl>
                        <dt>■通常チャット</dt>
                        <dd>
                            <br />
                            機能はデモ環境と全く同じです。Webブラウザから送信されたコメントはマインクラフト上でタイトル表示されます。<br />
                            もちろんマインクラフトからのチャットもWebブラウザへ送信されます。
                        </dd><br />
                        <dt>■プライベートチャット</dt>
                        <dd>
                            <br />
                            機能はデモ環境と全く同じですが、Websocketサーバー接続中にマルチプレイでウィスパー機能を使うと何故かワールドオーナー経由で送信される仕様になっているようですので、他の人が送信してもワールドオーナーが送信した事にされてしまいます。ですのでマルチプレイ時のウィスパー機能の使用は極力お控えください。<br /><br />

                            また、Websocket上のプライベート送信機能（&lt;メッセージ>#<ユーザー名&gt;）をマルチプレイ時に使うとマインクラフトのチャット機能が働いて他のマインクラフトユーザーに見えてしまいますので、あくまでWebブラウザユーザーとの通信手段だとお考えください。
                        </dd>
                    </dl><br />
                    <br />
                    <img src="./img/extra-minecraft-contents/chat.gif" /><br /><br />
                    <br />
                    <br />

                    <a id="bow_thunder"></a>
                    <h3 class="underline">いなずまの弓</h3>

                    <br />
                    以下のように矢を放った方向へ稲妻を落とせます。<br />
                    <img src="./img/extra-minecraft-contents/ground.gif" /><br /><br />

                    空を見上げるアングルではこんなイメージ<br />
                    <img src="./img/extra-minecraft-contents/sky_thunder.png" height="600px" width="728px" /><br /><br />

                    矢を放ったタイミングで稲妻を落とすので、近距離／遠距離の同時攻撃が可能なチート装備です。<br />
                    自分がダメージを受けないギリギリのところへ落とすようにしているのでサバイバルモードでも安心です。<br /><br />

                    地上だけではなく以下の場所でも使える事を確認しています。<br />

                    <ul>
                        <li>水中</li>
                        <li>洞窟</li>
                        <li>ネザー</li>
                        <li>エンド</li>
                    </ul>

                    何故か雲がないのにネザーやエンドでも使えるようです。<br /><br />

                    操作に慣れてくれば矢で牽制しながら稲妻を落とせるので帯電クリーパーやピグリンも量産し放題でしょう。<br /><br />

                    <h4>「いなずまの弓」の取得</h4>

                    ビヘイビアパックを適用しておけば、以下のコマンドでユニークアイテムとして「いなずまの弓」が手に入ります。<br />

                    <img src="./img/extra-minecraft-contents/drop.gif" /><br /><br />


                    <h4>サーバー側の実装</h4>

                    今回のアイテムの実装では"ItemUsed"というサブスクライブイベントを使用しています。<br/>
                    マインクラフト上でアイテムを使ったと認識されると発生するイベントのようで、フレームワークを使って以下の内容を実装しています。<br /><br />

                    ※サブスクライブイベントについては<font><a href="./extra-minecraft.html#send" target="_blank">&gt;&gt; こちら</a></font>でご紹介しています。<br />

                    <span>弓を使った時に発生するイベントデータの形式</span>
                    <pre>
{
    "body":
    {
        "count":<数字>,
        "item":
        {
            "aux":<数字>,
            "id":"bow",
            "namespace":<文字列>
        },
        "player":
        {
            "color":<16進数？>,
            "dimension":<数字>,
            "id":<数字>,
            "name":<文字列>,
            "position":
            {
                "x":<数字>,
                "y":<数字>,
                "z":<数字>
            },
            "type":<文字列>,
            "variant":<数字>,
            "yRot":<数字>
        },
        "useMethod":<数字>
    },
    "header":
    {
        "eventName":"ItemUsed",
        "messagePurpose":<文字列>,
        "version":<数字>
    }
}
                    </pre><br />

                    <h4>－ 以下の実装はフレームワークを使う上でのお決まりの書き方です －</h4>

                    <br />
                    イベントを処理するための任意のコマンド名を以下のファイルへ定義します。<br />
                    <span>app/CommandUnits/CommandQueueEnumForMinecraft.php</span>
                    <pre color-change="php">
case ITEM_USED = 'item_used';
                    </pre><br />

                    コマンド名を以下の場所へ追加して利用可能にします。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected const QUEUE_LIST = [
    CommandQueueEnumForMinecraft::ITEM_USED->value
];
                    </pre><br />

                    コマンド名と処理（関数）の関係を以下のメソッドへ追加して紐づけを行います。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
public function getUnitList(string $p_que): array
{
    $ret = [];
    ・
    ・
    ・
    if($p_que === CommandQueueEnumForMinecraft::ITEM_USED->value)
    {
        $ret[] = [
            'status' => CommandStatusEnumForMinecraft::START->value,
            'unit' => $this->getItemUsedStart()
        ];
    }

    return $ret;
}
                    </pre><br />

                    <h4>－ 以下の３点は今回の実装で特に重要な部分です －</h4>

                    サブスクライブイベントは以下の設定ファイルへ登録します（複数登録可）。<br />
                    これをいれておく事で、弓を使ったイベントを検知してマインクラフトがWebsocketサーバーへイベントデータを送信してくれます。<br />

                    <span>setting/minecraft.php</span>
                    <pre color-change="php">
return [
    'subscribe_types' =>
    [
        'ItemUsed'
    ]
];
                    </pre><br />

                    受信したイベントデータをコマンド名へ変換する処理を以下のコマンドディスパッチャーへ追加します。<br />
                    ※ここでは<code>bow</code>というアイテム名を検知しています。<br />
                    <span>app/InitClass/InitForMinecraft.php</span>
                    <pre color-change="php">
public function getCommandDispatcher()
{
    return function(ParameterForMinecraft $p_param, $p_dat): ?string
    {
        $minecraft = $p_param->isMinecraft();
        if($minecraft === true)
        {
            ・
            ・
            ・
            if(isset($p_dat['data']['header']['eventName']) && $p_dat['data']['header']['eventName'] === 'ItemUsed')
            {
                if($p_dat['data']['body']['item']['id'] === 'bow')
                {
                    return CommandQueueEnumForMinecraft::ITEM_USED->value;
                }
            }
            ・
            ・
            ・
        }
    }
}
                    </pre><br />

                    コマンド名に紐づけた処理（関数）を以下のファイルへ実装します。<br />
                    ※処理の冒頭で<code>aux</code>の数字を判定していますが、この<code>aux</code>がないと全ての弓アイテム使用時に発動してしまいます。<br />
                    ※「いなずまの弓」の<code>aux</code>データ値（401）はビヘイビアパックで定義しています。<br />
                    ※ここでは受信した座標データと三角関数を使って稲妻を落とす座標を計算した後マインクラフトへ<code>summon</code>コマンドを送信しています。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected function getItemUsedStart()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT ITEM_USED:START' => 'START']);

        if($rcv['data']['body']['item']['aux'] !== 401)
        {
            return null;
        }

        // 受信データの取得
        $rcv = $p_param->getRecvData();
        $x = (float)$rcv['data']['body']['player']['position']['x'];
        $y = (float)$rcv['data']['body']['player']['position']['y'];
        $x = (float)$rcv['data']['body']['player']['position']['z'];
        $y_rot = (float)$rcv['data']['body']['player']['yRot'];
        $y_rot_abs = abs($y_rot);

        // Z座標の計算
        $z = cos(deg2rad($y_rot_abs)) * 5;

        // X座標の計算
        $x = sin(deg2rad($y_rot_abs)) * 5;
        if($y_rot > 0)
        {
            $x = -$x;
        }

        // コマンド送信
        $cmd_data = $p_param->getCommandDataForThunderBow($x, 0, $z);
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

        return null;
    };
}
                    </pre><br />

                    <a id="arrow_thunder"></a>
                    <h3 class="underline">いなずまの矢</h3>

                    <br />
                    以下のように矢を放った場所へ稲妻を落とせます。<br />
                    <img src="./img/extra-minecraft-contents/arrow.gif" /><br /><br />

                    <h4>「いなずまの矢」の取得</h4>

                    ビヘイビアパックを適用しておけば、以下のコマンドでユニークアイテムとして「いなずまの矢」が手に入ります。<br />

                    <img src="./img/extra-minecraft-contents/drop_arrow.gif" /><br /><br />

                    ちなみに先に作っていた「いなずまの弓」とコンボするとこんなイメージ。<br />
                    <img src="./img/extra-minecraft-contents/combo.gif" /><br /><br />

                    これで安全に帯電クリーパーやピグリンも量産し放題でしょう。<br /><br />


                    <h4>サーバー側の実装</h4>

                    「いなずまの弓」の時と同様に今回のアイテムの実装では"ItemUsed"というサブスクライブイベントを使用しています。<br/>
                    マインクラフト上でアイテムを使ったと認識されると発生するイベントのようで、フレームワークを使って以下の内容を実装しています。<br /><br />

                    ※サブスクライブイベントについては<font><a href="./extra-minecraft.html#send" target="_blank">&gt;&gt; こちら</a></font>でご紹介しています。<br />

                    <span>矢を放った時に発生するイベントデータの形式</span>
                    <pre>
{
    "body":
    {
        "count":<数字>,
        "item":
        {
            "aux":411,
            "id":"arrow",
            "namespace":<文字列>
        },
        "player":
        {
            "color":<16進数？>,
            "dimension":<数字>,
            "id":<数字>,
            "name":<文字列>,
            "position":
            {
                "x":<数字>,
                "y":<数字>,
                "z":<数字>
            },
            "type":<文字列>,
            "variant":<数字>,
            "yRot":<数字>
        },
        "useMethod":<数字>
    },
    "header":
    {
        "eventName":"ItemUsed",
        "messagePurpose":<文字列>,
        "version":<数字>
    }
}
                    </pre><br />

                    今回の実装では「いなずまの弓」を作った時と処理フローが少し異なります。<br /><br />

                    <h4>【いなずまの弓の場合】</h4>

                    <dl>
                        <dt>(1)ItemUsedイベント（弓を使った時）の発生</dt>
                        <dt>(2)稲妻を落とす座標を計算してsummonコマンドを発行</dt>
                    </dl><br />

                    <h4>【いなずまの矢の場合】</h4>

                    <dl>
                        <dt>(1)ItemUsedイベント（弓を使った時）の発生</dt>
                        <dt>(2)放った矢にタグを発行</dt>
                        <dt>(3)ItemUsedイベント（矢を放った時）の発生</dt>
                        <dt>(4)放った矢の場所にsummonコマンドを発行</dt>
                    </dl><br />

                    上記の事から大きく分けて二つの大きな違いがあります。<br /><br />

                    まず一つ目はイベントが２回発行されるという事です。<br />
                    つまり「弓を使ったイベント」⇒「矢を放ったイベント」の順で２回発行されます。<br /><br />

                    そして二つ目の違いは放った矢にタグを付与しているところです。<br />
                    これはJava版でも同じでしたが弓で矢を放つと別のエンティティ（矢）としてスポーンしますので、「いなずまの矢」を放ったプレイヤーの矢（エンティティ）にタグを付与する事で特別な矢である事を認識させます。<br />
                    そして稲妻を落とす時（summonコマンド発行時）にターゲットセレクタでタグを指定するようにしています。<br />
                    これをしておかないと通常の矢を放った時でも発動してしまいます。<br /><br />

                    あと忘れてはいけないのはWebsocketサーバーからはexecuteコマンドを発行できないという事です。<br />
                    元々このコマンドはエンティティから実行されるように設計されているようなのでWebsocketサーバーはエンティティだと認識されていないからです。<br />
                    そのため今回はWebsocketサーバーからfunctionコマンドを発行する事で実際のコマンド処理をビヘイビアパックで賄うようにしています。<br /><br />

                    以上の事を踏まえて今回は以下のように実装しています。<br /><br />

                    <h4>－ 以下の実装はフレームワークを使う上でのお決まりの書き方です －</h4>

                    <br />
                    今回はイベントが２回発行される事から「いなずまの弓」実装時のコマンドをそのまま使うのでステータスUNITを追加します。<br />
                    まずは下記で今回用のステータス名を追加定義します。<br />
                    <span>app/CommandUnits/CommandStatusEnumForMinecraft.php</span>
                    <pre color-change="php">
case ARROW = 'arrow';
                    </pre><br />

                    コマンド名と処理（関数）の関係を以下のメソッドへ追加して紐づけを行います。<br />
                    ※以下の黄色の部分が今回追加したところです。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
public function getUnitList(string $p_que): array
{
    $ret = [];
    ・
    ・
    ・
    if($p_que === CommandQueueEnumForMinecraft::ITEM_USED->value)
    {
        $ret[] = [
            'status' => CommandStatusEnumForMinecraft::START->value,
            'unit' => $this->getItemUsedStart()
        ];
<font class="pre-yellow">
        $ret[] = [
            'status' => CommandStatusEnumForMinecraft::ARROW->value,
            'unit' => $this->getItemUsedArrow()
        ];
</font>
    }

    return $ret;
}
                    </pre><br />

                    <h4>－ 以下の３点は今回の実装で特に重要な部分です －</h4>

                    受信したイベントデータをコマンド名へ変換する処理を以下のコマンドディスパッチャーへ追加します。<br />
                    ※ここでは<code>arrow</code>というアイテム名を検知しています。<br />
                    ※以下の黄色の部分が今回追加したところです。<br />
                    <span>app/InitClass/InitForMinecraft.php</span>
                    <pre color-change="php">
public function getCommandDispatcher()
{
    return function(ParameterForMinecraft $p_param, $p_dat): ?string
    {
        $minecraft = $p_param->isMinecraft();
        if($minecraft === true)
        {
            ・
            ・
            ・
            if(isset($p_dat['data']['header']['eventName']) && $p_dat['data']['header']['eventName'] === 'ItemUsed')
            {
                // 弓イベントの場合
                if($p_dat['data']['body']['item']['id'] === 'bow')
                {
                    return CommandQueueEnumForMinecraft::ITEM_USED->value;
                }

<font class="pre-yellow">
                // 矢イベントの場合
                if($p_dat['data']['body']['item']['id'] === 'arrow')
                {
                    return CommandQueueEnumForMinecraft::ITEM_USED->value;
                }
</font>
            }
            ・
            ・
            ・
        }
    }
}
                    </pre><br />

                    「いなずまの弓」を実装した時のUNIT処理を以下のように修正して、２回目の<code>ItemUsed</code>イベントに備えて<code>getItemUsedArrow</code>メソッドのUNITへ処理を繋ぎます。<br />
                    ※<code>getCommandDataForArrowTag</code>メソッドが矢にタグを付与するコマンド文字列を生成している所です。<br />
                    ※以下の黄色の部分が今回追加・修正したところです。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected function getItemUsedStart()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT ITEM_USED:START' => 'START']);

        // 受信データの取得
        $rcv = $p_param->getRecvData();

<font class="pre-yellow">
        // ディスパッチャー強制
        $p_param->setForcedDispatcher(true);

        // コマンド送信
        $cmd_data = $p_param->getCommandDataForArrowTag($rcv['data']['body']['player']['name']);
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

        if($rcv['data']['body']['item']['aux'] !== 401)
        {
            return CommandStatusEnumForMinecraft::ARROW->value;
        }
</font>

        $x = (float)$rcv['data']['body']['player']['position']['x'];
        $y = (float)$rcv['data']['body']['player']['position']['y'];
        $x = (float)$rcv['data']['body']['player']['position']['z'];
        $y_rot = (float)$rcv['data']['body']['player']['yRot'];
        $y_rot_abs = abs($y_rot);

        // Z座標の計算
        $z = cos(deg2rad($y_rot_abs)) * 5;

        // X座標の計算
        $x = sin(deg2rad($y_rot_abs)) * 5;
        if($y_rot > 0)
        {
            $x = -$x;
        }

        // コマンド送信
        $cmd_data = $p_param->getCommandDataForThunderBow($x, 0, $z);
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

<font class="pre-yellow">
        return CommandStatusEnumForMinecraft::ARROW->value;
</font>
    };
}
                    </pre><br />

                    <code>CommandStatusEnumForMinecraft::ARROW</code>ステータス名に紐づけた処理（関数）を以下のファイルへ実装します。<br />
                    ※ここでは２つ目の<code>ItemUsed</code>イベントを受信（aux=411）した時にマインクラフトへ<code>function</code>コマンドを送信（getCommandDataForThunderArrowメソッドでコマンド文字列を生成）しています。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected function getItemUsedArrow()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT ITEM_USED:ARROW' => 'START']);

        $sta = $p_param->getStatusName();

        // 受信データの取得
        $rcv = $p_param->getRecvData();
        if($rcv === null)
        {
            // ディスパッチャー強制
            $p_param->setForcedDispatcher(true);
            return $sta;
        }

        // ItemUsed以外のイベントの判定
        if(!(isset($rcv['data']['header']['eventName']) && $rcv['data']['header']['eventName'] === 'ItemUsed'))
        {
            return $sta;
        }

        // コマンドデータの取得
        $cmd_data = null;
        if($rcv['data']['body']['item']['aux'] === 411)
        {
            // いなずまの矢
            $cmd_data = $p_param->getCommandDataForThunderArrow($rcv['data']['body']['player']['name']);
        }
        else
        {
            return $sta;
        }

        // コマンド送信
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

        return null;
    };
}
                    </pre><br />

                    <a id="arrow_explode"></a>
                    <h3 class="underline">はかいの矢</h3>

                    <br />
                    以下のように矢を放った場所が爆発します。<br />
                    <img src="./img/extra-minecraft-contents/arrow_explode.gif" /><br /><br />

                    <h4>「はかいの矢」の取得</h4>

                    ビヘイビアパックを適用しておけば、以下のコマンドでユニークアイテムとして「はかいの矢」が手に入ります。<br />
                    <img src="./img/extra-minecraft-contents/drop_arrow_explode.gif" /><br /><br />

                    以下のようにスロットを置き換える事で「いなずまの矢」と使い分けができます。<br />
                    <img src="./img/extra-minecraft-contents/arrow_slot_change.gif" /><br /><br />

                    スロット番号は以下のように左から順番に割り振られています。アイテム使用時は若い数字の方が優先されます。<br />
                    <img src="./img/extra-minecraft-contents/bottom_slot.png" /><br />
                    ※スロット番号についてはインベントリの詳細も含めて<font><a href="https://minecraft.fandom.com/ja/wiki/%E3%82%A4%E3%83%B3%E3%83%99%E3%83%B3%E3%83%88%E3%83%AA">&gt;&gt; こちら</a></font>のページで詳しく説明されています。<br /><br />

                    ちなみに先に作っていた「いなずまの弓」とコンボするとこんなイメージ。<br />
                    <img src="./img/extra-minecraft-contents/combo_explode.gif" /><br /><br />

                    あまり使い過ぎるとワールド地形が悲惨な事になるので注意しましょう。<br /><br />


                    <h4>サーバー側の実装</h4>

                    「いなずまの弓」の時と同様に今回のアイテムの実装では"ItemUsed"というサブスクライブイベントを使用しています。<br/>
                    マインクラフト上でアイテムを使ったと認識されると発生するイベントのようで、フレームワークを使って以下の内容を実装しています。<br /><br />

                    ※サブスクライブイベントについては<font><a href="./extra-minecraft.html#send" target="_blank">&gt;&gt; こちら</a></font>でご紹介しています。<br />

                    <span>矢を放った時に発生するイベントデータの形式</span>
                    <pre>
{
    "body":
    {
        "count":<数字>,
        "item":
        {
            "aux":421,
            "id":"arrow",
            "namespace":<文字列>
        },
        "player":
        {
            "color":<16進数？>,
            "dimension":<数字>,
            "id":<数字>,
            "name":<文字列>,
            "position":
            {
                "x":<数字>,
                "y":<数字>,
                "z":<数字>
            },
            "type":<文字列>,
            "variant":<数字>,
            "yRot":<数字>
        },
        "useMethod":<数字>
    },
    "header":
    {
        "eventName":"ItemUsed",
        "messagePurpose":<文字列>,
        "version":<数字>
    }
}
                    </pre><br />

                    今回の実装は「いなずまの矢」とほとんど同じです。<br />
                    「いなずまの矢」の場合は最後に<code>summon</code>コマンドで雷を呼び出していましたが、今回はエンダークリスタルを呼び出しています。<br /><br />

                    以上の事を踏まえて今回は「いなずまの矢」の実装時に追加したUNIT処理へ以下の処理を追加しています。<br /><br />

                    ※以下の黄色の部分が今回追加したところです。<br />
                    ※ここでは２つ目の<code>ItemUsed</code>イベントを受信（aux=421）した時にマインクラフトへ<code>function</code>コマンドを送信（getCommandDataForExplodeArrowメソッドでコマンド文字列を生成）しています。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected function getItemUsedArrow()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT ITEM_USED:ARROW' => 'START']);

        $sta = $p_param->getStatusName();

        // 受信データの取得
        $rcv = $p_param->getRecvData();
        if($rcv === null)
        {
            // ディスパッチャー強制
            $p_param->setForcedDispatcher(true);
            return $sta;
        }

        // ItemUsed以外のイベントの判定
        if(!(isset($rcv['data']['header']['eventName']) && $rcv['data']['header']['eventName'] === 'ItemUsed'))
        {
            return $sta;
        }

        // コマンドデータの取得
        $cmd_data = null;
        if($rcv['data']['body']['item']['aux'] === 411)
        {
            // いなずまの矢
            $cmd_data = $p_param->getCommandDataForThunderArrow($rcv['data']['body']['player']['name']);
        }
<font class="pre-yellow">
        else
        if($rcv['data']['body']['item']['aux'] === 421)
        {
            // はかいの矢
            $cmd_data = $p_param->getCommandDataForExplodeArrow($rcv['data']['body']['player']['name']);
        }
</font>
        else
        {
            return $sta;
        }

        // コマンド送信
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

        return null;
    };
}
                    </pre><br />

                    <a id="double_jump"></a>
                    <h3 class="underline">二段ジャンプ</h3>

                    <br />
                    以下のように２回目のジャンプボタンで二段ジャンプが発動します。<br />
                    <img src="./img/extra-minecraft-contents/double_jump.gif" /><br /><br />

                    一度ジャンプして着地するかしないかのタイミングで以下のように画面右端にガイドが表示されます（赤枠の部分）。<br />
                    そのタイミングでもう一度ジャンプボタンを押すと発動します。<br />
                    <img src="./img/extra-minecraft-contents/double_jump_guide.png" height="600px" width="728px" /><br /><br />

                    ※特別なアイテムは使用していませんが通信量を減らすため<code>function</code>コマンドを使用していますのでビヘイビアパックを適用しておく必要があります。<br /><br />

                    <h4>サーバー側の実装</h4>

                    今回はジャンプイベントが発生した時に送信される"PlayerTravelled"というサブスクライブイベントを使用しています。<br />
                    "PlayerTransform"の上位版のようで<code>travelMethod</code>というパラメータ値をみてそのイベントがジャンプイベントなのかそれ以外なのかを判断できるようになっています。<br /><br />

                    ※サブスクライブイベントについては<font><a href="./extra-minecraft.html#send" target="_blank">&gt;&gt; こちら</a></font>でご紹介しています。<br />

                    <span>ジャンプ時に発生するイベントデータの形式</span>
                    <pre>
{
    "body":
    {
        "isUnderwater":<ブール値>,
        "metersTravelled":<数字>,
        "newBiome":<数字>,
        "player":
        {
            "color":<16進数？>,
            "dimension":<数字>,
            "id":<数字>,
            "name":<文字列>,
            "position":
            {
                "x":<数字>,
                "y":<数字>,
                "z":<数字>
            },
            "type":<文字列>,
            "variant":<数字>,
            "yRot":<数字>
        },
        "travelMethod":2（ジャンプ）
    },
    "header":
    {
        "eventName":"PlayerTravelled",
        "messagePurpose":<文字列>,
        "version":<数字>
    }
}
                    </pre><br />

                    注意しないといけないのが、この"PlayerTravelled"イベントはジャンプイベントが発生した時に１回だけ発行されるわけではありません。<br />
                    最初にジャンプイベントが発生したタイミングから着地するまでの間はゲームチック毎に複数回イベントが発生します。<br /><br />

                    このような性質があるため二段ジャンプを連発し過ぎたり、ジャンプブースト（effectコマンドの設定値）を高く設定し過ぎたりするとラグが発生する事があるので注意が必要です。<br /><br />

                    <h4>－ 以下の実装はフレームワークを使う上でのお決まりの書き方です －</h4>

                    イベントを処理するための任意のコマンド名を以下のファイルへ定義します。<br />
                    <span>app/CommandUnits/CommandQueueEnumForMinecraft.php</span>
                    <pre color-change="php">
case PLAYER_TRAVELLED = 'player_travelled';
                    </pre><br />

                    コマンド名を以下の場所へ追加して利用可能にします。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
protected const QUEUE_LIST = [
    CommandQueueEnumForMinecraft::PLAYER_TRAVELLED->value
];
                    </pre><br />

                    コマンド名と処理（関数）の関係を以下のメソッドへ追加して紐づけを行います。<br />
                    <span>app/CommandUnits/CommandForMinecraft.php</span>
                    <pre color-change="php">
public function getUnitList(string $p_que): array
{
    $ret = [];
    ・
    ・
    ・
    if($p_que === CommandQueueEnumForMinecraft::PLAYER_TRAVELLED->value)
    {
        $ret[] = [
            'status' => CommandStatusEnumForMinecraft::START->value,
            'unit' => $this->getMinecraftPlayerTravelledStart()
        ];
        $ret[] = [
            'status' => CommandStatusEnumForMinecraft::JUMP->value,
            'unit' => $this->getMinecraftPlayerTravelledJump()
        ];
    }

    return $ret;
}
                    </pre><br />

                    <h4>－ 以下の３点は今回の実装で特に重要な部分です －</h4>

                    サブスクライブイベントは以下の設定ファイルへ登録します（複数登録可）。<br />
                    これをいれておく事で、ジャンプ時のイベントを検知してマインクラフトがWebsocketサーバーへイベントデータを送信してくれます。<br />

                    <span>setting/minecraft.php</span>
                    <pre color-change="php">
return [
    'subscribe_types' =>
    [
        'PlayerTravelled'
    ]
];
                    </pre><br />

                    受信したイベントデータをコマンド名へ変換する処理を以下のコマンドディスパッチャーへ追加します。<br />
                    <span>app/InitClass/InitForMinecraft.php</span>
                    <pre color-change="php">
public function getCommandDispatcher()
{
    return function(ParameterForMinecraft $p_param, $p_dat): ?string
    {
        $minecraft = $p_param->isMinecraft();
        if($minecraft === true)
        {
            ・
            ・
            ・
            if(isset($p_dat['data']['header']['eventName']) && $p_dat['data']['header']['eventName'] === 'PlayerTravelled')
            {
                return CommandQueueEnumForMinecraft::PLAYER_TRAVELLED->value;
            }
            ・
            ・
            ・
        }
    }
}
                    </pre><br />

                    コマンド名に紐づけた以下二つの処理（関数）を実装します。<br />

                    <span>app/CommandUnits/CommandForMinecraft.php（STARTステータスのUNIT）</span>
                    <pre color-change="php">
protected function getMinecraftPlayerTravelledStart()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT PLAYER_TRAVELLED:START' => 'START']);

        // 受信データの取得
        $rcv = $p_param->getRecvData();

        // ジャンプイベント以外の場合
        if($rcv['data']['body']['travelMethod'] !== 2 || $rcv['data']['body']['metersTravelled'] <= 1.16)
        {
            return null;
        }

        // コマンド送信
        $cmd_data = $p_param->getCommandDataForDoubleJump($rcv['data']['body']['player']['name']);
        $data =
        [
            'data' => $cmd_data
        ];
        $p_param->setSendStack($data);

        // ディスパッチャー強制
        $p_param->setForcedDispatcher(true);

        return CommandStatusEnumForMinecraft::JUMP->value;
    };
}
                    </pre><br />

                    上記のSTARTステータスのUNITでは初回のジャンプイベントを受信した時に<code>getCommandDataForDoubleJump</code>メソッドで<code>function</code>コマンドを生成して送信しています。<br />

                    <span>app/CommandUnits/CommandForMinecraft.php（JUMPステータスのUNIT）</span>
                    <pre color-change="php">
protected function getMinecraftPlayerTravelledJump()
{
    return function(ParameterForMinecraft $p_param): ?string
    {
        $p_param->logWriter('debug', ['MINECRAFT PLAYER_TRAVELLED:JUMP' => 'START']);

        $sta = $p_param->getStatusName();

        // 受信データの取得
        $rcv = $p_param->getRecvData();
        if($rcv === null)
        {
            goto end_second_event;
        }

        // PlayerTravelledイベントの判定
        if(isset($rcv['data']['header']['eventName']) && $rcv['data']['header']['eventName'] === 'PlayerTravelled')
        {
            if($rcv['data']['body']['travelMethod'] === 2)
            {
                goto end_second_event;
            }
            else
            {
                // コマンド送信
                $cmd_data = $p_param->getCommandDataForFallDamage($rcv['data']['body']['player']['name'], true);
                $data =
                [
                    'data' => $cmd_data
                ];
                $p_param->setSendStack($data);

                return null;
            }
        }
        else
        {
            // PlayerTravelled以外のイベント
            goto end_second_event;
        }

end_second_event:

        // ディスパッチャー強制
        $p_param->setForcedDispatcher(true);
        return $sta;
    };
}
                    </pre><br />

                    上記のJUMPステータスのUNITではジャンプイベントが継続している間は処理を待ち受けて、イベントが途切れた時に<code>getCommandDataForFallDamage</code>メソッドで落下ダメージ有効化（gamerule）コマンドを生成して送信しています。
                </div><br />

                <a id="last"></a>
                <h2 class="subtitle">おわりに</h2>

                <div class="text-block">
                    Websocketサーバー上でイベントが取得できるようになっただけでもかなり負担が減らせるので助かります。<br />
                    座標計算等の処理もサーバーサイドのスクリプトで自由に組める事と、WebブラウザをUIとして使えるメリットも大きいと思います。<br /><br />

                    機能的に物足りないところもまだ残ってはいますが、今後のマインクラフトのアップデートにも期待を持ちたいところです。
                </div>
            </div>
        </div>
    </body>
</html>
